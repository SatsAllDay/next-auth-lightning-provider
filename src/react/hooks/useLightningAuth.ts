"use client";

import { useState, useEffect } from "react";

import { createApiRequest, pollApiRequest } from "../utils/api.js";
import { hardConfig } from "../../main/config/hard.js";
import { formatLightningAuth } from "../utils/lnurl.js";

/**
 * A React hook that, on mount, will trigger an API request and create a new Lightning login session.
 * Thereafter, it'll poll the API and checks if the Lightning auth QR has been scanned.
 * If enough time elapses without a login attempt, the Lightning login session will be refreshed.
 * Once a success status is received from polling, the user will be redirected to the `redirectUri`.
 *
 * @param {String} redirectUri - the `redirect_uri` query param generated by `next-auth`
 * @param {String} state - the `state` query param generated by `next-auth`
 * @param {String} errorUri - a path or url which the user should be redirected to if there's an error - optional
 *
 * @returns {Object}
 * @returns {String} lnurl - the raw LNURL, should be made available for copy-pasting
 * @returns {String} qr - a url pointing the lnurl-auth QR Code image, should be used in the src prop of img tags
 * @returns {String} button - a deep-link that will open in Lightning enabled wallets, should be used in the href prop of anchor tags
 */
export function useLightningAuth({
  redirectUri,
  state,
  errorUri,
}: {
  redirectUri: string;
  state: string;
  errorUri?: string;
}): {
  lnurl: string | null;
  qr: string;
  button: string;
} {
  const [lnurl, setUrl] = useState<string | null>(null);

  useEffect(() => {
    let data: { k1?: string; lnurl?: string } | null;
    let pollTimeoutId: NodeJS.Timeout | undefined;
    let createIntervalId: NodeJS.Timeout | undefined;
    const pollController = new AbortController();
    const createController = new AbortController();

    // cleanup when the hook unmounts of polling is successful
    const cleanup = () => {
      clearTimeout(pollTimeoutId);
      clearInterval(createIntervalId);
      pollController.abort();
      createController.abort();
    };

    // redirect user to error page if something goes wrong
    const error = (e: any) => {
      const params = new URLSearchParams();
      params.append("error", "OAuthSignin");
      if (e?.message) params.append("message", e.message);
      window.location.replace(
        (errorUri || "/api/auth/signin") + "?" + params.toString()
      );
    };

    // poll the api to see if successful login has occurred
    const poll = async () => {
      const k1 = data?.k1;
      try {
        if (k1) {
          const { success } = await pollApiRequest(k1, pollController.signal);
          if (success) {
            cleanup();
            let url = new URL(redirectUri);
            url.searchParams.append("state", state);
            url.searchParams.append("code", k1);
            window.location.replace(url);
          }
        }
        pollTimeoutId = setTimeout(poll, hardConfig.intervals.poll);
      } catch (e: any) {
        if (!createController.signal.aborted) {
          error(e);
        }
      }
    };

    // create a new lnurl and set it to state
    const create = async () => {
      try {
        data = await createApiRequest(state, createController.signal);
        setUrl(data?.lnurl || null);
      } catch (e: any) {
        if (!createController.signal.aborted) {
          error(e);
        }
      }
    };

    // setup intervals and create first qr code
    pollTimeoutId = setTimeout(poll, hardConfig.intervals.poll);
    createIntervalId = setInterval(create, hardConfig.intervals.create);
    create();

    return () => cleanup();
  }, []);

  const { qr, button } = formatLightningAuth(lnurl);

  return { lnurl, qr, button };
}
